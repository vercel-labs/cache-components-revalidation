---
title: Revalidating cached data
description: Learn how to keep cached pages fresh with periodic revalidation using cacheLife and on-demand revalidation using cacheTag and revalidateTag.
nav_title: Revalidating
---

Cached pages load fast, but the data behind them can go stale. A product's price changes, a description gets updated, new inventory arrives. You need a way to refresh cached content without rebuilding and redeploying your entire app.

This guide covers two revalidation strategies: **periodic revalidation** to refresh data on a time-based schedule, and **on-demand revalidation** to expire specific cache entries the moment data changes.

It builds on the product detail page from the [page variants guide](/docs/app/guides/page-variants).

## Example

We'll take the existing product detail page that already uses [`'use cache'`](/docs/app/api-reference/directives/use-cache) and [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params) and add a cache lifetime so product data refreshes daily. Then we'll add cache tags so individual products can be revalidated instantly through an API route.

You can find the resources used in this example here:

- [Demo](https://cache-components-public-pages-revalidation.labs.vercel.dev/)
- [Code](https://github.com/vercel-labs/cache-components-public-pages-revalidation)

### Step 1: Set a cache lifetime with `cacheLife`

The product data function currently uses `'use cache'` with no explicit cache lifetime:

```tsx filename="app/products/data.ts"
export async function getProduct(slug: string): Promise<Product> {
  'use cache'
  const response = await fetch(
    `https://next-recipe-api.vercel.dev/products/${slug}`,
  )
  return response.json()
}
```

With the default cache profile, data is considered stale after a short window and expires after a long one. For product data that changes infrequently, we want a longer freshness window.

Import [`cacheLife`](/docs/app/api-reference/functions/cacheLife) from `next/cache` and call it inside the cached function:

```tsx filename="app/products/data.ts"
import { cacheLife } from 'next/cache'

export async function getProduct(slug: string): Promise<Product> {
  'use cache'
  cacheLife('days')
  const response = await fetch(
    `https://next-recipe-api.vercel.dev/products/${slug}`,
  )
  return response.json()
}
```

If we run [`next build`](/docs/app/api-reference/cli/next#next-build-options), the route table reflects the new lifetime:

```bash filename="Terminal"
Route (app)                    Revalidate  Expire
├ ◐ /products/[slug]           1d          1w
└ ◐ /_not-found

◐  (Partial Prerender)  prerendered as static HTML with dynamic server-streamed content
```

#### Cache lifetime profiles

**`cacheLife`** accepts a named profile that configures how long cached data stays fresh before revalidating in the background. The built-in profiles are:

| Profile     | Stale | Revalidate | Expire |
| ----------- | ----- | ---------- | ------ |
| `'seconds'` | 30s   | 1s         | 1m     |
| `'minutes'` | 5m    | 1m         | 1h     |
| `'hours'`   | 5m    | 1h         | 1d     |
| `'days'`    | 5m    | 1d         | 1w     |
| `'weeks'`   | 5m    | 1w         | 30d    |
| `'max'`     | 5m    | 30d        | 1y     |

With `cacheLife('days')`, the data is served from cache immediately, [revalidated](/docs/app/glossary#revalidation) in the background after a day, and expires after a week. This means the first visitor after the revalidation window gets a stale response while a fresh one is generated — subsequent visitors get the updated data.

### Step 2: Tag and revalidate on demand

Periodic revalidation works for data that changes on a predictable schedule. But when a product's price is updated in your CMS, you don't want to wait up to a day for the change to appear.

#### Cache tags

Import [`cacheTag`](/docs/app/api-reference/functions/cacheTag) and call it inside the cached function to label the cache entry:

```tsx filename="app/products/data.ts"
import { cacheLife, cacheTag } from 'next/cache'

export async function getProduct(slug: string): Promise<Product> {
  'use cache'
  cacheTag(`product-${slug}`)
  cacheLife('days')
  const response = await fetch(
    `https://next-recipe-api.vercel.dev/products/${slug}`,
  )
  return response.json()
}
```

**`cacheTag`** attaches one or more string labels to a cache entry. These tags don't affect caching behavior on their own — they exist so you can target specific entries for invalidation later.

You can tag the product list function too, so the full data layer looks like this:

```tsx filename="app/products/data.ts"
import { cacheLife, cacheTag } from 'next/cache'

export async function getProducts(): Promise<Product[]> {
  'use cache'
  cacheTag('products')
  cacheLife('days')
  const response = await fetch('https://next-recipe-api.vercel.dev/products')
  return response.json()
}

export async function getProduct(slug: string): Promise<Product> {
  'use cache'
  cacheTag(`product-${slug}`)
  cacheLife('days')
  const response = await fetch(
    `https://next-recipe-api.vercel.dev/products/${slug}`,
  )
  return response.json()
}
```

#### On-demand revalidation

To invalidate a tagged entry, call [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) from a [Route Handler](/docs/app/building-your-application/routing/route-handlers) or [Server Action](/docs/app/building-your-application/data-fetching/server-actions-and-mutations).

Create an API route that accepts a tag and invalidates it:

```tsx filename="app/api/revalidate/route.ts"
import { revalidateTag } from 'next/cache'
import type { NextRequest } from 'next/server'

export async function POST(request: NextRequest) {
  const { tag } = await request.json()
  revalidateTag(tag, 'days')
  return Response.json({ revalidated: true, tag })
}
```

When this endpoint receives a POST request, it marks all cache entries matching the given tag as expired. The next visitor to that page triggers a fresh render with updated data.

You can test this locally with `curl`:

```bash filename="Terminal"
curl -X POST http://localhost:3000/api/revalidate \
  -H 'Content-Type: application/json' \
  -d '{"tag": "product-shorts"}'
```

This returns:

```json
{ "revalidated": true, "tag": "product-shorts" }
```

The next request to `/products/shorts` will fetch fresh product data instead of serving the cached version.

In production, this endpoint is what your CMS calls via a webhook when content changes. A product is updated in the CMS → the CMS sends a POST to `/api/revalidate` with the product's tag → the cached entry is marked as expired → the first visitor gets fresh data and subsequent visitors get cached data.

## Next steps

You now know how to control cache lifetimes with `cacheLife` and invalidate specific cache entries on demand with `cacheTag` and `revalidateTag`.

Next, learn how to:

- [Build private pages with user data](/docs/app/guides/private-pages)
- [Compose subshells for nested cached layouts](/docs/app/guides/subshell-composition)
